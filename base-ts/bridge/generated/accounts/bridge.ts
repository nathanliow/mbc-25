/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getBaseOracleConfigDecoder,
  getBaseOracleConfigEncoder,
  getBufferConfigDecoder,
  getBufferConfigEncoder,
  getEip1559Decoder,
  getEip1559Encoder,
  getGasConfigDecoder,
  getGasConfigEncoder,
  getPartnerOracleConfigDecoder,
  getPartnerOracleConfigEncoder,
  getProtocolConfigDecoder,
  getProtocolConfigEncoder,
  type BaseOracleConfig,
  type BaseOracleConfigArgs,
  type BufferConfig,
  type BufferConfigArgs,
  type Eip1559,
  type Eip1559Args,
  type GasConfig,
  type GasConfigArgs,
  type PartnerOracleConfig,
  type PartnerOracleConfigArgs,
  type ProtocolConfig,
  type ProtocolConfigArgs,
} from '../types';

export const BRIDGE_DISCRIMINATOR = new Uint8Array([
  231, 232, 31, 98, 110, 3, 23, 59,
]);

export function getBridgeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(BRIDGE_DISCRIMINATOR);
}

export type Bridge = {
  discriminator: ReadonlyUint8Array;
  /** The Base block number associated with the latest registered output root. */
  baseBlockNumber: bigint;
  /** Incremental nonce assigned to each outgoing message. */
  nonce: bigint;
  /** Guardian pubkey authorized to update bridge configuration parameters */
  guardian: Address;
  /** Whether the bridge is paused (emergency stop mechanism) */
  paused: boolean;
  /** EIP-1559 state and configuration for dynamic pricing. */
  eip1559: Eip1559;
  /** Configuration parameters for outgoing message pricing */
  gasConfig: GasConfig;
  /** Configuration parameters for bridge protocol */
  protocolConfig: ProtocolConfig;
  /** Configuration parameters for pre-loading Solana --> Base messages in buffer accounts */
  bufferConfig: BufferConfig;
  /** Partner oracle configuration containing the required signature threshold */
  partnerOracleConfig: PartnerOracleConfig;
  /** Configuration parameters for Base oracle signers */
  baseOracleConfig: BaseOracleConfig;
};

export type BridgeArgs = {
  /** The Base block number associated with the latest registered output root. */
  baseBlockNumber: number | bigint;
  /** Incremental nonce assigned to each outgoing message. */
  nonce: number | bigint;
  /** Guardian pubkey authorized to update bridge configuration parameters */
  guardian: Address;
  /** Whether the bridge is paused (emergency stop mechanism) */
  paused: boolean;
  /** EIP-1559 state and configuration for dynamic pricing. */
  eip1559: Eip1559Args;
  /** Configuration parameters for outgoing message pricing */
  gasConfig: GasConfigArgs;
  /** Configuration parameters for bridge protocol */
  protocolConfig: ProtocolConfigArgs;
  /** Configuration parameters for pre-loading Solana --> Base messages in buffer accounts */
  bufferConfig: BufferConfigArgs;
  /** Partner oracle configuration containing the required signature threshold */
  partnerOracleConfig: PartnerOracleConfigArgs;
  /** Configuration parameters for Base oracle signers */
  baseOracleConfig: BaseOracleConfigArgs;
};

export function getBridgeEncoder(): FixedSizeEncoder<BridgeArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['baseBlockNumber', getU64Encoder()],
      ['nonce', getU64Encoder()],
      ['guardian', getAddressEncoder()],
      ['paused', getBooleanEncoder()],
      ['eip1559', getEip1559Encoder()],
      ['gasConfig', getGasConfigEncoder()],
      ['protocolConfig', getProtocolConfigEncoder()],
      ['bufferConfig', getBufferConfigEncoder()],
      ['partnerOracleConfig', getPartnerOracleConfigEncoder()],
      ['baseOracleConfig', getBaseOracleConfigEncoder()],
    ]),
    (value) => ({ ...value, discriminator: BRIDGE_DISCRIMINATOR })
  );
}

export function getBridgeDecoder(): FixedSizeDecoder<Bridge> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['baseBlockNumber', getU64Decoder()],
    ['nonce', getU64Decoder()],
    ['guardian', getAddressDecoder()],
    ['paused', getBooleanDecoder()],
    ['eip1559', getEip1559Decoder()],
    ['gasConfig', getGasConfigDecoder()],
    ['protocolConfig', getProtocolConfigDecoder()],
    ['bufferConfig', getBufferConfigDecoder()],
    ['partnerOracleConfig', getPartnerOracleConfigDecoder()],
    ['baseOracleConfig', getBaseOracleConfigDecoder()],
  ]);
}

export function getBridgeCodec(): FixedSizeCodec<BridgeArgs, Bridge> {
  return combineCodec(getBridgeEncoder(), getBridgeDecoder());
}

export function decodeBridge<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Bridge, TAddress>;
export function decodeBridge<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Bridge, TAddress>;
export function decodeBridge<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Bridge, TAddress> | MaybeAccount<Bridge, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getBridgeDecoder()
  );
}

export async function fetchBridge<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Bridge, TAddress>> {
  const maybeAccount = await fetchMaybeBridge(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeBridge<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Bridge, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeBridge(maybeAccount);
}

export async function fetchAllBridge(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Bridge>[]> {
  const maybeAccounts = await fetchAllMaybeBridge(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeBridge(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Bridge>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeBridge(maybeAccount));
}

export function getBridgeSize(): number {
  return 528;
}
